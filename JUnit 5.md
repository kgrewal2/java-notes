# Writing Tests

## Annotations

## Meta Annotations and Composed Annotations

JUnit Jupiter annotations can be used as meta-annotations. Using custom composed annotations, we can use `@Fast` instead of `@Tag("fast")`.

```java
@Target({ElementType.Type, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Tag("fast")
public @interface Fast {
}
```

```java
@Fast
@Test
void myFastTest() {
    // ..
}
```

One more improvement can be done to constitute `@Fast` and `@Test` into a single tag.

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Tag("fast")
@Test
public @interface FastTest {
}
```

```java
@FastTest
void myFastTest() {
}
```

## Test Classes and Methods

**Test Class**
Top-level class, static member class, or `@Nested` class that contains at least one *test method.*

**Test Method**
Any instance method that is directly annotated or meta-annotated with `@Test`, `@RepeatedTest`, `@ParameterizedTest`, `@TestFactory`, or `@TestTemplate`.

**Lifecycle Method**
Any method annotated or meta-annotated with `@BeforeAll`, `@AfterAll`, `@BeforeEach`, or `AfterEach`. 

```java
class StandardTestClass {
    @BeforeAll
    static void initAll() {
    }
    
    @BeforeEach
    void init() {
    }
    
    @Test
    void succeedingTest() {
	}
    
    @Test
    void failingTest() {
	}
    
    @Test
    @Disabled("for demonstration purposes")
    void skippedTest() {
        // Not Executed
	}
    
    @Test
    void abortedTest() {
        assumeTrue("abc".contains("Z"));
        fail("Test should have been aborted");
	}
    
    @AfterEach
    void teadDown() {
	}
    
    @AfterAll
    static void tearDownAll() {
	}
    
    @Test
    void failingTest() {
	}
}
```

## Display Names

Custom Display Names can be set using `@DisplayName`.

```java
@DisplayName("Calculator Test Cases")
class CalculatorTest {
    // ..
    @Test
    @DisplayName("Checking add method")
    void testingAddMethod() {
        // ..
    }
}
```

### Display Name Generators

`@DisplayNameGenerator` can be configured to generate display names. However, `@DisplayName` annotation always take precedence over display names generated by a `DisplayNameGenerator`.

Default DisplayNameGenerator Types:

1. Standard
2. Simple (Removes trailing parenthese for methods with no parameters)
3. ReplaceUnderscores (Replaces underscores with spaces)
4. IndicativeSentence (Generates complete sentences by concatenating the names of test and enclosing classes)

> `IndicativeSentences` can be customized using `@IndicativeSentenceGeneration`.

### Setting the Default Display Name Generator

Set the property in `src/test/resources/junit-platform.properties`

```properties
junit.jupiter.displayname.generator.default = org.junit.jupiter.api.DisplayNameGenerator$ReplaceUnderscores
```

## Assertions

- `assertEquals(...)`

- `assertTrue(...)`

- `assertNotNull(...)`

- ```java
  assertAll("first name",
            () -> assertTrue(firstName.startsWith("J")),
            () -> assertTrue(firstName.endsWith("e"))
           );
  ```

- `supplier` must complete its execution before the given timeout is exceeded. The `supplier` execution runs on the same thread and execution keeps running even if timed out.

  ```java
  // assertTimeout(Duration timeout, ThrowingSupplier supplier)
  ```

  ```java
  assertTimeout(ofMinutes(2), () -> {
      // Perform task that takes less than 2 minutes
  });
  ```

- `supplier` must complete its execution before the given timeout is exceeded. The `supplier` execution runs on a different thread and execution is stopped if timed out.

  ```java
  assertTimeoutPreemptively(ofMillis(10), () -> {
      new CountDownLatch(1).await();
  })
  ```

  ## Assumptions

```java
@Test
void testDeveloperWorkstation() {
    assumeTrue(...);
    assertTrue(...);
}
```

## Disabling Tests

```java
@Disabled("Disabled until bug #42 has been resolved.")
class DisabledTests {
    ...
}
```

```java
@Disabled("Disabled Test")
@Test
void testWillBeSkipped() {
    ...
}
```

## Conditional Test Execution

`ExecutionCondition` extension API in JUnit Jupitor allows to set conditions on containers or tests. 

### Operating System Conditions

```java
@Test
@EnabledOnOs(MAC)
void runOnMacOs() {
    ...
}

@Test
@DisabledOnOs(WINDOWS)
void notOnWindows() {
    ...
}
```

### Java Runtime Environment Conditions

```java
@Test
@EnableOnJre(JAVA_8)
void onlyOnJava8() {
    ...
}

@Test
@EnableForJreRange(min=JAVA_9, max=JAVA_11)
void fromJava9to11() {
    ...
}
```

### System Property Conditions

```java
@Test
@EnabledIfSystemProperty(named="os.arch", matches=".*64.*")
void onlyOn64BitArchitecture() {
    ...
}
```

### Environment Variable Conditions

```java
@Test
@EnabledIfEnvironmentVariable(named="ENV", matches="staging-server.*")
void onlyOnStagingServer() {
    ...
}
```

### Custom Conditions

```java
@Test
@EnabledIf("customCondition")
void enabled() {
    ...
}

boolean customCondition() {
    return true;
}
```

## Tagging and Filtering

`@Tag` annotation can be used to tag test classes and methods. These tags can be used to filter test discovery and execution.

1. A tag must not be `null` or *blank*.
2. A *trimmed tag* must not contain whitespaces.
3. A *trimmed tag* must not contain ISO control characters.
4. A *trimmed tag* must not contain any of the following *reserved characters.*
   - Comma `,`
   - Left/Right Parenthesis `( )`
   - Ampersand `&`
   - Vertical Bar `|`
   - Exclamation Point `!`

> *Trimmed Tag* means that leading and trailing whitespace characters have been removed.

```java
@Tag("fast")
@Tag("model")
class TaggingClass {
    
    @Test
    @Tag("taxes")
    void testingTaxCalculation() {
        ...
    }
    
}
```

## Execution Order

True *unit tests* typically should not rely on the order in which they are executed. There are times like writing *integration/functional* tests or different *lifecycles*, the execution order can be configured using `MethodOrderer`.

1. DisplayName: Sorts tests methods alphanumerically based on their display names.

2. MethodName: Sorts tests methods alphanumerically based on their method names and formal parameter lists.

3. OrderAnnotation: Sorts test methods numerically based on values specified via the `@Order` annotation.

   ```java
   @Test
   @Order(2)
   void someMethod() {
       ...
   }
   
   @Test
   @Order(1)
   void anotherMethod() {
       ...
   }
   ```

4. Random: Can be configured to custom seed.

5. Alphanumeric: Deprecated. Same as MethodName.

### Default Method Orderer

Properties File: src/test/resources/junit-platform.properties

```properties
junit.jupiter.testmethod.order.default = org.junit.jupiter.api.MethodOrderer$OrderAnnotation
```

## Test Instance Lifecycle

JUnit's default behaviour (*per-method*) is to create new instance of each test class before executing each test method.

If you would prefer that all test methods be executed on the same test instance, you can annotate the test class with `@TestInstance(Lifecycle.PER_CLASS)`.  In this mode, it is possible to declare `@BeforeAll` and `@AfterAll` on non-static methods as well as on interface default methods.

### Default Test Instance Lifecycle

Properties File: src/test/resources/junit-platform.properties

```properties
junit.jupiter.testinstance.lifecycle.default=per_class
```

In addition to this, we also need to set this property in the JVM command using

```sh
-Djunit.jupiter.testinstance.lifecycle.default=per_class
```

## Nested Tests

```java
@DisplayName("Calculator Testing Suite")
class CalculatorTest {

    private int power;

    @Test
    @DisplayName("Test 1")
    void test1() {
        assertEquals(1, 1);
    }

    @Nested
    @DisplayName("Calculator Power Cables Testing Suite")
    class PowerTesting {
        @BeforeEach
        void givePower() {
            power = 100;
        }

        @Test
        @DisplayName("Full Power")
        void fullPower() {
            assumeTrue(power == 100);
        }

        @Test
        @DisplayName("Sufficient Power")
        void sufficientPower() {
            assumeTrue(power > 50);
        }

        @Nested
        @DisplayName("Power Delivery")
        class PowerDeliveryTesting {

            @Test
            @DisplayName("Proper Delivery")
            void properDelivery() {
                assertEquals(power,100);
            }
        }
    }
}
```

```sh
✓ Test Results
	✓ Calculating Testing Suite
		✓ Test 1
		✓ Calculator Power Cables Testing Suite
			✓ Sufficient Power
			✓ Full Power
			✓ Power Delivery
				✓ ProperDelivery
```

## Dependency Injection for Constructors and Methods

`ParameterResolver` allows to dynamically resolve parameters at runtime. 
If a *test class* constructor, a *test method*, or a *lifecycle method* accepts a parameter, the parameter must be resolved at runtime by a registered `ParameterResolver`.

### TestInfoParamterResolver

If the constructor or method parameter is of `TestInfo` type, the `TestInfoParameterResolver` will supply an instance of `TestInfo` corresponding to the current container or test as the value for the parameter. 

```java
@DisplayName("Calculator Testing Suite")
class CalculatorTest {

    CalculatorTest(TestInfo testInfo) {
        assertEquals("Calculator Testing Suite", testInfo.getDisplayName());
    }

    @Test
    @DisplayName("Test 1")
    void test1(TestInfo testInfo) {
        assertEquals("Test 1", testInfo.getDisplayName());
    }
}
```

### RepititionInfoParameterResolver

If a method parameter in a `@RepeatedTest`, `@BeforeEach`, or `@AfterEach` method is of type `RepitionInfo`, the `RepititionInfoParameterResolver` will supply an instance of `RepitionInfo`,

The info variable can be used to retrieve information about the current repetition and the total number of repetitions for the corresponding `@RepeatedTest`.

### TestReportedParameterResolver

This is used for publishing additional data about the current test run. The data can be consumed via `reportedEntryPublished()` method in `TestExecutionListener`.

```java
@DisplayName("Calculator Testing Suite")
class CalculatorTest {
    @Test
    @DisplayName("Test 1")
    void test1(TestReporter testReporter) {
        testReporter.publishEntry("Key", "Value");
    }

    @Test
    void reportMultipleKeyValuePairs(TestReporter testReporter) {
        Map<String, String> values = new HashMap<>();
        values.put("user name", "dk38");
        values.put("award year", "1974");
        testReporter.publishEntry(values);
    }
}
```

> `RandomParametersExtension` can be used to inject random values into `@Test` methods.